package com.codingwithmitch.processor

import com.codingwithmitch.annotation.Greeting
import com.squareup.kotlinpoet.*
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind.INTERFACE

const val CLASS_HEADER = "Generated by Mitch just for lols."
const val GREETING_NAME_SUFFIX = "_Greeting"

internal class GreetingBuilder(
    private val environment: ProcessingEnvironment,
) {

    private lateinit var fullClassName: ClassName

    fun generate(
        element: Element,
    ) {
        if (element.kind != INTERFACE) {
            environment.error(
                "${element.simpleName}: @Greeting annotation can only decorate an interface."
            )
            return
        }

        val pkg = element.getPackage(environment)
            .also { fullClassName = element.getFullClassName(environment, it) }
        val fileName = fullClassName.asFileName(GREETING_NAME_SUFFIX)
        val greeting = element.getAnnotationMirror<Greeting>()!!
        val text = greeting.getParameter<String>(TEXT_NAME)

        if (text.isNullOrEmpty()) {
            environment.error(
                "${element.simpleName}: @Greeting must contain some text."
            )
            return
        }
        val typeBuilder = greetingTypeBuilder(
            fileName = fileName,
            superInterface = fullClassName,
            text = text,
        )

//        element.enclosedElements
//            .filterMethods()
//            .filter { it.simpleName.toString() == INJECT_METHOD_NAME }
//            .map(::injectFunction)
//            .filterNotNull()
//            .forEach { typeBuilder.addFunction(it) }

        val fileSpec = FileSpec.builder(pkg, fileName)
            .addType(typeBuilder.build())
            .build()
        fileSpec.writeTo(environment.filer)
    }

    private fun greetingTypeBuilder(
        fileName: String,
        superInterface: TypeName,
        text: String,
    ): TypeSpec.Builder {
        return TypeSpec.classBuilder(fileName)
            .addKdoc(CLASS_HEADER)
            .addSuperinterface(superInterface)
            .addSuperinterface(BaseGreeting::class.asTypeName())
            .addProperties(
                listOf(
                    PropertySpec.builder("text", STRING)
                        .addModifiers(KModifier.OVERRIDE)
                        .mutable()
                        .initializer("%S", text)
                        .build()
                )
            )
    }

//    private fun injectFunction(method: ExecutableElement): FunSpec? {
//        if (method.parameters.size != 1) {
//            environment.error("$method: $INJECT_METHOD_NAME() methods must have a single parameter.")
//            return null
//        }
//        val parameter = method.parameters.single()
//        if (!method.returnType.isVoid()) {
//            environment.error("$method: $INJECT_METHOD_NAME() methods must have no return value.")
//            return null
//        }
//
//        val paramName = parameter.simpleName.toString()
//        val paramElement = parameter.asType()
//            .asTypeElement()
//        val code = CodeBlock.builder()
//
//        paramElement.enclosedElements
//            .injectingFields(environment)
//            .forEach {
//                val result = it.setFieldInTarget(
//                    environment = environment,
//                    targetParamName = paramName,
//                    targetClassElement = paramElement,
//                    code = code
//                )
//                if (!result) return@injectFunction null
//            }
//
//        return FunSpec.builder(method.simpleName.toString())
//            .addModifiers(KModifier.OVERRIDE)
//            .addParameter(paramName, parameter.asType().asTypeName())
//            .addCode(code.build())
//            .build()
//    }

    private companion object {
        const val INJECT_METHOD_NAME = "inject"
        const val TEXT_NAME = "text"
    }
}






